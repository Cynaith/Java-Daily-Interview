## JavaSE语法

### Java中&和&&区别
&运算符有两种用法:(1)按位与;(2)逻辑与。
<br/>
&&运算符是短路与运算。如果&&左边的表达式的值是 false，右边的表达式会被直接短路掉，不会进行 运算。
> 例如在验证用户登录时判定用户名不是 null 而且不是空字符串，应 当写为 username != null &&!username.equals("")，二者的顺序不能交换，更不能用&运算符，因为第一个条件如 果不成立，根本不能进行字符串的 equals 比较，否则会产生 NullPointerException 异常。

逻辑或运算符(|) 和短路或运算符(||)的差别也是如此。

### 两个对象值相同，hash应当相同
1. 如果两个对象相同(equals 方法返回 true)，那 么它们的 hashCode 值一定要相同;
2. 如果两个对象的 hashCode 相同，它们并不一定相同。

### String类不可以被继承 
String类是final类，不可以被继承

### Java中的参数传递
是值传递。Java 语言的方法调用只支持参数的值传递。当一个对象实例作为一个参数被传递到方法中时，参数的 值就是对该对象的引用。
对象的属性可以在被调用过程中被改变，但对对象引用的改变是不会影响到调用者的。

### 重载(overload)和重写(override)的区别?重载的方法能否根据返回类型进行区分?
方法的重载和重写都是实现多态的方式，区别在于前者实现的是编译时的多态性，而后者实现的是运行时的多态性。
<br/>
重载对返回类型没有特殊的要求。
<br/>
方法重载的规则:
    1. 方法名一致，参数列表中参数的顺序，类型，个数不同。 
    2. 重载与方法的返回值无关，存在于父类和子类，同类中。 
    3. 可以抛出不同的异常，可以有不同修饰符。
    <br/>
方法重写的规则:
    1. 参数列表必须完全与被重写方法的一致，返回类型必须完全与被重写方法的返回类型一致。 
    2. 构造方法不能被重写，声明为 final 的方法不能被重写，声明为 static 的方法不能被重写，但是能够被再次声明。
    3. 访问权限不能比父类中被重写的方法的访问权限更低。 
    4. 重写的方法能够抛出任何非强制异常(UncheckedException，也叫非运行时异常)，无论被重写的方法是否抛出异常。
    但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常，反之则可以。

### 为什么函数不能根据返回类型来区分重载?
> 华为面试题

因为调用时不能指定类型信息，编译器不知道你要调用哪个函数。
<br/>
函数的返回值只是作为函数运行之后的一个“状态”，他是保持方法的调用者与被调用者进行通信的关键。并不能作为某个方法的“标识”。

### char 型变量中能不能存储一个中文汉字，为什么?
char 类型可以存储一个中文汉字，因为 Java 中使用的编码是Unicode(不选择任何特定的编码，直接使用字符在字符集中的编号,这是统一的唯一方法)，
一个char类型占 2 个字节(16 比特)，所以放一个中文是没问题的。
> 使用 Unicode 意味着字符在 JVM 内部和外部有不同的表现形式，在 JVM 内部都是 Unicode，当这个字符被 从 JVM 内部转移到外部时(例如存入文件系统中)，需要进行编码转换。
>所以 Java 中有字节流和字符流，以及在字 符流和字节流之间进行转换的转换流，如 InputStreamReader 和 OutputStreamReader，这两个类是字节流和字符 流之间的适配器类，承担了编码转换的任务;
>对于 C 程序员来说，要完成这样的编码转换恐怕要依赖于 union(联合 体/共用体)共享内存的特征来实现了。

### 抽象类和接口有什么异同
- 不同
    - 抽象类
    1. 抽象类中可以定义构造器
    2. 可以有抽象方法和具体方法
    3. 抽象类中的成员可以是 private、默认、protected、public
    4. 抽象类中可以定义成员变量
    5. 有抽象方法的类必须被声明为抽象类，而抽象类未必要有抽象方法
    6. 抽象类中可以包含静态方法
    7. 一个类只能继承一个抽象类
    - 接口
    1. 接口中不能定义构造器
    2. 方法全部都是抽象方法
    3. 接口中的成员全都是 public的（接口的意义是规范类对外的行为方法，而不是对类内部的实现做限制。）
    4. 接口中定义的成员变量实际上都是常量
    5. 接口中不能有静态方法
    6. 一个类可以实现多个接口
- 相同
1. 不能够实例化
2. 可以将抽象类和接口类型作为引用类型
3. 一个类如果继承了某个抽象类或者实现了某个接口都需要对其中的抽象方法全部进行实现，否则该类仍然需要被声明为抽象类
    
### 抽象的(abstract)方法是否可同时是静态的(static), 是否可同时是本地方法 (native)，是否可同时被 synchronized？
都不能。抽象方法需要子类重写，而静态的方法是无法被重写的，因此二者是矛盾的。[本地方法](https://blog.csdn.net/asdasdasd123123123/article/details/81910116)是由本地代码(如 C 代码)实现的方法，而抽象方法是没有实现的，也是矛盾的。synchronized 和方法的实现细节有关， 抽象方法不涉及实现细节，因此也是相互矛盾的。

### 阐述静态变量和实例变量的区别?
**静态变量:** 是被 static 修饰符修饰的变量，也称为类变量，它属于类，不属于类的任何一个对象，一个类不管创建多少个对象，静态变量在内存中有且仅有一个拷贝。
**实例变量:** 必须依存于某一实例，需要先创建对象然后通过对象才能访问到它。静态变量可以实现让多个对象共享内存。

### ==和 equals 的区别?
一个是方法一个是运算符
<br/>
**equals():** 比较两个对象的内容是否相同
**==:**  如果比较的对象是基本数据类型，则比较的是数值是否相等;如果比较的是引用数据类型，则比较的是对象的地址值是否相等。

### String的使用
例如我们要在构造器中对一个名叫 s 的 String 引用变量进行初始化，把它设置为初始值，应当这样做:
```java
    public class Demo {
        private String s;
        ...
        s = "Initial Value";
        ...
    }
```
而非
```java
    s = new String("Initial Value");
```
后者每次都会调用构造器，生成新对象，性能低下且内存开销大，并且没有意义，因为 String 对象不可改变，所以对于内容相同的字符串，只要一个 String 对象来表示就可以了。也就说，多次调用上面的构造器创建多个对象，他 们的 String 类型属性 s 都指向同一个对象。