## Effective Java

### 第一章 创建和销毁对象
1. [考虑用静态工厂方法代替构造函数](#考虑用静态工厂方法代替构造函数)
2. [使用私有构造函数强化singleton属性](#使用私有构造函数强化singleton属性)
3. [通过私有构造函数强化不可实例的能力](#通过私有构造函数强化不可实例的能力)
4. [避免创建重复的对象](#避免创建重复的对象)
5. [消除过期的对象引用](#消除过期的对象引用)


#### 考虑用静态工厂方法代替构造函数
为了获得一个类的实例，除了提供一个公有的构造函数，类还可以提供一个公有的静态工厂方法(就是一个静态方法，返回类的实例)。
- 优点
    - 与构造函数不同，静态方法具有名字
        - 易于阅读。例如：如果构造函数返回值不确定，则使用静态方法命名可以表法更清楚。或多个构造函数的情况下。
    - 与构造函数不同，不用每次调用时都创建一个新的对象
    - 与构造函数不同，它们可以返回一个原返回类型的子类型的对象
- 缺点
    - 类如果不含公有的或者受保护的构造函数，就不能被子类化
    - 与其他静态方法没有任何区别
#### 使用私有构造函数强化singleton属性
实现singleton有两种方法，其都要把构造函数保持为私有的，并且提供一个静态成员，以便客户端能够访问该类唯一的实例。
- 第一种方法公有静态成员是一个final域。  
  第一种方法的好处在于性能上稍微领先，但是一个优秀的JVM实现应该能够通过将静态工厂方法的调用内联化，来消除这种差别
- 第二种方法提供了一个公有静态工厂方法。    
  第二种方法的好处在于灵活，在不改变API的前提，可以将类做成singleton或者不做。
  
使singleton变为可序列化的，不能仅仅在声明中加上`implements Serializable` 。为了维护singleton，要提供一个readResolve方法。 
```java
    private Object readResolve() throws ObjectStreamException{
        return INSTANCE;
    }
```

#### 通过私有构造函数强化不可实例的能力
企图将一个类做成抽象类来强制该类不可被实例化，这是行不通的。有一些简单的习惯用法可以确保一个类不可被实例化。
```java
public class UtilityClass{
    private UtilityClass(){
        // This constructor will never be invoked
    }
}
```
#### 避免创建重复的对象

#### 消除过期的对象引用
